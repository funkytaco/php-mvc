# Nimbus Password Manager

## Overview

The Nimbus Password Manager is a centralized system for managing passwords across all Nimbus applications. It provides automatic password generation, secure storage via Ansible Vault, and intelligent password resolution strategies.

## Architecture

### Core Components

1. **PasswordManager** (`src/Nimbus/Password/PasswordManager.php`)
   - Main entry point for password operations
   - Determines password strategy based on priority hierarchy
   - Handles password generation and extraction

2. **PasswordSet** (`src/Nimbus/Password/PasswordSet.php`)
   - Data container for all passwords needed by an app
   - Includes database, Keycloak admin, Keycloak DB, and client secret passwords
   - Tracks the strategy used and whether force initialization is required

3. **PasswordStrategy** (`src/Nimbus/Password/PasswordStrategy.php`)
   - Enum defining three strategies: VAULT_RESTORE, EXISTING_DATA, GENERATE_NEW
   - Used to track how passwords were obtained

## Password Resolution Hierarchy

The password manager uses a strict priority hierarchy when determining which passwords to use:

### 1. VAULT_RESTORE (Highest Priority)
- Checks if Ansible Vault is initialized
- Looks for existing credentials for the app in vault
- Used when: Vault contains saved passwords for the app
- Benefits: Consistent passwords across recreations, secure storage

### 2. EXISTING_DATA
- Checks for existing PostgreSQL data directory (`/data/[appName]`)
- Attempts to extract passwords from running containers
- Used when: App has existing data but no vault backup
- Risk: May fail if containers are stopped/removed

### 3. GENERATE_NEW (Lowest Priority)
- Generates new secure passwords
- Used when: No vault credentials and no existing data
- Default length: 32 characters (alphanumeric only for shell safety)

## Password Flow in Commands

### `composer nimbus:create [appName]`
1. Checks vault for existing credentials
2. Displays found credentials to user
3. Creates app from template
4. Password manager resolves passwords using hierarchy
5. Placeholders in template files are replaced with actual passwords
6. Auto-backs up new passwords to vault (if vault initialized)

### `composer nimbus:install [appName]`
1. Calls `generatePodmanCompose()`
2. Password manager resolves passwords using hierarchy
3. Generates compose file with resolved passwords
4. Backs up passwords to vault (if vault initialized)

### `composer nimbus:up [appName]`
1. Uses the compose file generated by install
2. Starts containers with injected passwords
3. No password resolution happens here

## Template Password System

### Placeholder Usage
Templates use placeholders instead of hardcoded passwords:
- `{{DB_PASSWORD}}` - Database password
- `{{KEYCLOAK_ADMIN_PASSWORD}}` - Keycloak admin password
- `{{KEYCLOAK_DB_PASSWORD}}` - Keycloak database password
- `{{KEYCLOAK_CLIENT_SECRET}}` - OAuth client secret

### Placeholder Resolution
During `createFromTemplate` in AppManager:
1. PasswordManager resolves passwords based on strategy
2. Passwords are stored in a `PasswordSet` object
3. Placeholders are replaced in `generateAppConfigWithPasswords`:
   - Template files are processed
   - Placeholders are replaced with actual values
   - Modified files are written to the app directory

### Password Sources
- **Vault (VAULT_RESTORE)**: Retrieved from `.installer/vault/credentials.yml`
- **Existing Containers (EXISTING_DATA)**: Extracted via `podman inspect`
- **Generated (GENERATE_NEW)**: New 32-character alphanumeric passwords

### Template Security
- No production passwords are stored in templates
- Only development test user has hardcoded password (`testpass123`)
- All sensitive passwords use placeholders
- Passwords are dynamically resolved at creation time

## Known Issues

### Old Password Injection Problem

**Symptom**: After removing containers and recreating an app, old passwords may be injected instead of vault passwords.

**Root Cause**: 
1. The `EXISTING_DATA` strategy checks for PostgreSQL files in `/data/[appName]`
2. If found, it tries to extract passwords from **running containers**
3. If containers don't exist, it falls back to generating new passwords
4. These new passwords don't match the existing database

**Current Logic Flow**:
```php
// In determineStrategy()
1. Check vault (has credentials) → VAULT_RESTORE ✓
2. Check existing data (has PG files) → EXISTING_DATA ✗
3. Generate new → GENERATE_NEW
```

**Problem**: When both vault credentials AND existing data exist, the system should prioritize vault and force database reinitialization.

### Solutions

1. **Short-term Fix**: Clean data directories before recreating apps
   ```bash
   rm -rf data/[appName]
   composer nimbus:create [appName]
   composer nimbus:install [appName]
   composer nimbus:up [appName]
   ```

2. **Long-term Fix**: Modify password strategy to:
   - Always use vault passwords when available
   - Set `requiresForceInit` flag when vault passwords differ from existing data
   - Add force-init.sh script to handle password mismatches

## Password Storage

### Vault Structure
Passwords are stored in Ansible Vault at:
```
.installer/vault/credentials.yml
```

Format:
```yaml
apps:
  [appName]:
    database:
      password: "..."
    keycloak:
      admin_password: "..."
      db_password: "..."
      client_secret: "..."
```

### Container Environment Variables
- Database: `POSTGRES_PASSWORD`
- Keycloak Admin: `KEYCLOAK_ADMIN_PASSWORD`
- Keycloak DB: `POSTGRES_PASSWORD`

## Security Considerations

1. **Password Generation**
   - Uses cryptographically secure random generation
   - Alphanumeric only to avoid shell escaping issues
   - Default 32 characters (configurable)

2. **Vault Security**
   - Encrypted with user-provided vault password
   - Vault password stored in `.installer/vault/.vault_pass`
   - Should be excluded from version control

3. **Container Security**
   - Passwords injected as environment variables
   - Not visible in compose files after generation
   - Stored encrypted in vault for persistence

## Best Practices

1. **Always Initialize Vault**
   ```bash
   composer nimbus:vault-init
   ```

2. **Backup Regularly**
   - Vault credentials are automatically backed up on app creation
   - Manual backup: `composer nimbus:vault-backup`

3. **Clean Removal**
   - Use `composer nimbus:delete [appName]` to properly clean up
   - Removes containers, volumes, and data directories

4. **Password Rotation**
   - Currently manual process
   - Future: Add `nimbus:rotate-passwords` command

## Troubleshooting

### "Wrong password" errors after recreation
- **Cause**: Password mismatch between vault and existing data
- **Fix**: Remove data directory and recreate, or manually update passwords

### Cannot extract passwords from containers
- **Cause**: Containers not running when using EXISTING_DATA strategy
- **Fix**: Start containers first or use vault backup

### Vault not saving passwords
- **Cause**: Vault not initialized or write permissions
- **Fix**: Run `composer nimbus:vault-init` and check permissions

## Future Enhancements

1. **Automatic Password Rotation**
   - Scheduled rotation with zero downtime
   - Coordinated updates across all services

2. **External Secret Management**
   - Integration with HashiCorp Vault
   - Kubernetes secrets support

3. **Password Complexity Options**
   - Configurable character sets
   - Compliance mode for specific requirements

4. **Improved Conflict Resolution**
   - Automatic detection of password mismatches
   - User prompts for resolution strategy

5. **Multi-Environment Support**
   - Different passwords for dev/staging/prod
   - Environment-specific vault files